{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@egjs/hammerjs/dist/hammer.esm.js","webpack:///./index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_extends","assign","target","arguments","length","source","apply","this","_inheritsLoose","subClass","superClass","constructor","__proto__","_assertThisInitialized","self","ReferenceError","win","assign$1","undefined","TypeError","output","index","nextKey","VENDOR_PREFIXES","TEST_ELEMENT","document","style","createElement","TYPE_FUNCTION","round","Math","abs","now","Date","prefixed","obj","prefix","prop","camelProp","toUpperCase","slice","window","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","forEach","val","getTouchActionProps","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","test","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_MOUSE","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","PROPS_CLIENT_XY","each","iterator","context","boolOrFn","args","inStr","str","find","indexOf","TouchAction","manager","set","_proto","compute","element","actions","toLowerCase","trim","update","options","touchAction","recognizers","recognizer","enable","concat","getTouchAction","hasPanX","hasPanY","cleanTouchActions","join","preventDefaults","input","srcEvent","direction","offsetDirection","session","prevented","preventDefault","hasNone","isTapPointer","pointers","isTapMovement","distance","isTapTouchTime","deltaTime","preventSrc","hasParent","node","parent","parentNode","getCenter","pointersLength","x","clientX","y","clientY","simpleCloneInputData","timeStamp","center","deltaX","deltaY","getDistance","p1","p2","props","sqrt","getAngle","atan2","PI","getDirection","getVelocity","computeInputData","firstInput","firstMultiple","offsetCenter","angle","offset","offsetDelta","prevDelta","prevInput","eventType","computeDeltaXY","overallVelocity","overallVelocityX","overallVelocityY","scale","start","end","getScale","rotation","getRotation","maxPointers","velocity","velocityX","velocityY","last","lastInterval","v","computeIntervalInputData","inputHandler","pointersLen","changedPointersLen","changedPointers","isFirst","isFinal","emit","recognize","splitStr","split","addEventListeners","types","handler","type","addEventListener","removeEventListeners","removeEventListener","getWindowForElement","doc","ownerDocument","defaultView","parentWindow","Input","callback","inputTarget","domHandler","ev","init","evEl","evTarget","evWin","destroy","inArray","src","findByKey","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","MSPointerEvent","PointerEvent","PointerEventInput","_Input","_this","proto","store","pointerEvents","removePointer","eventTypeNormalized","replace","pointerType","isTouch","storeIndex","pointerId","button","push","splice","toArray","Array","uniqueArray","sort","results","values","a","b","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_TARGET_EVENTS","TouchInput","targetIds","touches","targetTouches","allTouches","identifier","changedTouches","changedTargetTouches","filter","touch","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","MouseInput","pressed","which","DEDUP_TIMEOUT","DEDUP_DISTANCE","setLastTouch","eventData","primaryTouch","lastTouch","lts","lastTouches","setTimeout","TouchMouseInput","_manager","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","dx","dy","mouse","invokeArrayArg","arg","fn","isArray","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","_uniqueId","getRecognizerByNameIfManager","otherRecognizer","stateStr","state","Recognizer","id","simultaneous","requireFail","recognizeWith","dropRecognizeWith","requireFailure","dropRequireFailure","hasRequireFailures","canRecognizeWith","event","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","defaults","domEvents","inputClass","preset","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","toggleCssProps","add","oldCssProps","Manager","handlers","createInputInstance","item","stop","force","stopped","curRecognizer","existing","remove","targetRecognizer","on","events","off","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","triggerDomEvent","SINGLE_TOUCH_INPUT_MAP","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","SingleTouchInput","started","all","changed","AttrRecognizer","_Recognizer","attrTest","optionPointers","isRecognized","isValid","TapRecognizer","taps","interval","time","threshold","posThreshold","pTime","pCenter","_timer","_input","count","_this2","validPointers","validMovement","validTouchTime","failTimeout","validInterval","validMultiTap","_this3","clearTimeout","tapCount","directionStr","PanRecognizer","_AttrRecognizer","pX","pY","directionTest","hasMoved","SwipeRecognizer","PinchRecognizer","inOut","RotateRecognizer","PressRecognizer","validTime","deprecate","method","message","deprecationMessage","e","Error","stack","log","console","warn","extend","dest","merge","keys","inherit","child","base","properties","childP","baseP","_super","bindFn","hammer_esm","Hammer","VERSION","STATE_FAILED","Tap","Pan","Swipe","Pinch","Rotate","Press","hammer","querySelector","transform"],"mappings":"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","file":"canttouchthis.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*! Hammer.JS - v2.0.13 - 2018-10-29\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\n\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nvar assign$1 = assign;\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n    abs = Math.abs;\nvar now = Date.now;\n\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n\n    i++;\n  }\n\n  return undefined;\n}\n\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = 'ontouchstart' in win;\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n  var i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n\n  return val;\n}\n\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\nvar TouchAction =\n/*#__PURE__*/\nfunction () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n\n  var _proto = TouchAction.prototype;\n\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n\n  return TouchAction;\n}();\n\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  var x = 0;\n  var y = 0;\n  var i = 0;\n\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  var firstInput = session.firstInput,\n      firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n\n  if (hasParent(input.srcEvent.target, target)) {\n    target = input.srcEvent.target;\n  }\n\n  input.target = target;\n}\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\nvar Input =\n/*#__PURE__*/\nfunction () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n\n  var _proto = Input.prototype;\n\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n\n  return Input;\n}();\n\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n\n      i++;\n    }\n\n    return -1;\n  }\n}\n\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n};\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\n\nvar PointerEventInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n\n  function PointerEventInput() {\n    var _this;\n\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = PointerEventInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n\n  return PointerEventInput;\n}(Input);\n\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n\n  function TouchInput() {\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    TouchInput.prototype.targetIds = {};\n    return _Input.apply(this, arguments) || this; // this.evTarget = TOUCH_TARGET_EVENTS;\n    // this.targetIds = {};\n  }\n\n  var _proto = TouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return TouchInput;\n}(Input);\n\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n  i = 0;\n\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\n\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n\n  function MouseInput() {\n    var _this;\n\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = MouseInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n\n  return MouseInput;\n}(Input);\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n      touch = _eventData$changedPoi[0];\n\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar TouchMouseInput =\n/*#__PURE__*/\nfunction () {\n  var TouchMouseInput =\n  /*#__PURE__*/\n  function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n\n      _this = _Input.call(this, _manager, callback) || this;\n\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {\n          return;\n        }\n\n        _this.callback(manager, inputEvent, inputData);\n      };\n\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n\n    var _proto = TouchMouseInput.prototype;\n\n    /**\n     * @private\n     * remove the event listeners\n     */\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n\n    return TouchMouseInput;\n  }(Input);\n\n  return TouchMouseInput;\n}();\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n\n  return new Type(manager, inputHandler);\n}\n\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n\n  return false;\n}\n\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n  return _uniqueId++;\n}\n\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n\n  return otherRecognizer;\n}\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n\n  return '';\n}\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\nvar Recognizer =\n/*#__PURE__*/\nfunction () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n\n  var _proto = Recognizer.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n\n  _proto.reset = function reset() {};\n\n  return Recognizer;\n}();\n\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Default recognizer setup when calling `Hammer()`\n   * When creating a new Manager these will be skipped.\n   * @type {Array}\n   */\n  preset: [],\n\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n\n  if (!element.style) {\n    return;\n  }\n\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Manager =\n/*#__PURE__*/\nfunction () {\n  function Manager(element, options) {\n    var _this = this;\n\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n\n  var _proto = Manager.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    var i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && ( // 1\n      !curRecognizer || recognizer === curRecognizer || // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    var recognizers = this.recognizers;\n\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n\n    var existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    var i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n\n  return Manager;\n}();\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n\n  function SingleTouchInput() {\n    var _this;\n\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n\n  var _proto = SingleTouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return SingleTouchInput;\n}(Input);\n\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\nvar AttrRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n\n  var _proto = AttrRecognizer.prototype;\n\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n\n      return state | STATE_CHANGED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  return AttrRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\nvar TapRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n\n  function TapRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  var _proto = TapRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return TapRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n\n  return '';\n}\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PanRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n\n  function PanRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n\n  var _proto = PanRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n\n    return actions;\n  };\n\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PanRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar SwipeRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n\n  var _proto = SwipeRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  };\n\n  return SwipeRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PinchRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PinchRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar RotateRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = RotateRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  return RotateRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\nvar PressRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n\n  function PressRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n\n  var _proto = PressRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return PressRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n\n    i++;\n  }\n\n  return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Hammer =\n/*#__PURE__*/\nfunction () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new Manager(element, _extends({\n      recognizers: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n      [RotateRecognizer, {\n        enable: false\n      }], [PinchRecognizer, {\n        enable: false\n      }, ['rotate']], [SwipeRecognizer, {\n        direction: DIRECTION_HORIZONTAL\n      }], [PanRecognizer, {\n        direction: DIRECTION_HORIZONTAL\n      }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n        event: 'doubletap',\n        taps: 2\n      }, ['tap']], [PressRecognizer]]\n    }, options));\n  };\n\n  Hammer.VERSION = \"2.0.13\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = defaults;\n  return Hammer;\n}();\n\nexport default Hammer;\nexport { INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, Manager, Input, TouchAction, TouchInput, MouseInput, PointerEventInput, TouchMouseInput, SingleTouchInput, Recognizer, AttrRecognizer, TapRecognizer as Tap, PanRecognizer as Pan, SwipeRecognizer as Swipe, PinchRecognizer as Pinch, RotateRecognizer as Rotate, PressRecognizer as Press, addEventListeners as on, removeEventListeners as off, each, merge, extend, assign$1 as assign, inherit, bindFn, prefixed, toArray, inArray, uniqueArray, splitStr, boolOrFn, hasParent, addEventListeners, removeEventListeners, defaults };\n//# sourceMappingURL=hammer.esm.js.map\n","import Hammer from '@egjs/hammerjs';\n\nwindow.addEventListener('load', () => {\n\n  const hammer = new Hammer(document.querySelector('.overlay'));\n\n  hammer.get('pan').set({direction: Hammer.DIRECTION_ALL});\n\n  let offset = {x: 0, y: 0};\n\n  hammer.on('panend', e => {\n    console.log('panend');\n    offset.x += e.deltaX;\n    offset.y += e.deltaY;\n  });\n\n  hammer.on('pan', e => {\n    console.log('pan');\n    let div = document.querySelector('.box');\n    div.style.transform = `translate(${offset.x + e.deltaX}px, ${offset.y + e.deltaY}px)`;\n  });\n\n});"],"sourceRoot":""}